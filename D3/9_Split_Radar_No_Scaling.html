<!DOCTYPE html>
<!--
Copyright 2018 SAS Institute Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
<head>
  <!-- Import D3.js -->
  <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>

  <!-- Import d3-tip -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.9.1/d3-tip.min.js"></script>

  <!-- Import utilities  -->
  <script type="text/javascript" src="../../util/messagingUtil.js"></script>
  <script type="text/javascript" src="../../util/contentUtil.js"></script>
</head>
<body>
<style type="text/css">
  html, body, svg {
    float: left;
    min-width: 300px;
    min-height: 200px;
    margin: 0px;
    width: 100%;
    height: 100%;
  }

  text {
    font-family: Verdana, sans-serif;
  }

  .legend-title {
    font-size: .9em;
    font-weight: bold;
    text-anchor: middle;
    dominant-baseline: hanging;
  }

  .legend-text {
    font-size: .8em;
    dominant-baseline: central;
  }

  .legend-rect {
    stroke-width: 1;
  }

  .g-legend-entry {
    cursor: pointer;
  }

  .g-legend-entry.selected .legend-text {
    font-weight: bold;
  }

  .g-legend-entry.selected .legend-rect {
    stroke-width: 2px;
  }

  .data-path {
    pointer-events: none;
    stroke-width: 2;
  }

  .measure-label {
    font-size: .8em;
    dominant-baseline: hanging;
  }

  .d3-tip {
    pointer-events: none !important;
    background: white;
    position: relative;
    border: 1px solid #C4C4C4;
    border-radius: 2px;
  }

  /* Create arrow on tooltip */
  .d3-tip.n:before, .d3-tip.ne:before, .d3-tip.nw:before, .d3-tip.s:before, .d3-tip.se:before, .d3-tip.sw:before {
    content: "";
    position: absolute;
    border-style: solid;
    border-width: 5px 10px 5px 0;
    border-color: transparent #C4C4C4;
    transform-origin: 0% 0%;
  }

  .d3-tip.n:after, .d3-tip.ne:after, .d3-tip.nw:after, .d3-tip.s:after, .d3-tip.se:after, .d3-tip.sw:after {
    content: "";
    position: absolute;
    border-style: solid;
    border-width: 4px 8px 4px 0;
    border-color: transparent #fff;
    transform-origin: 0% 0%;
  }

  /* Move the arrow depending on direction */
  /* North */
  .d3-tip.n:before, .d3-tip.n:after {
    top: 100%;
    left: 50%;
    transform: rotate(-90deg) translate(-10px, -5px);
  }

  .d3-tip.n:after {
    transform: rotate(-90deg) translate(-7px, -4px);
  }

  /* North east */
  .d3-tip.ne:before, .d3-tip.ne:after {
    top: 100%;
    left: 0%;
    transform: rotate(-45deg) translate(-6px, -5px);
  }

  .d3-tip.ne:after {
    transform: rotate(-45deg) translate(-3px, -4px);
  }

  /* North west */
  .d3-tip.nw:before, .d3-tip.nw:after {
    top: 100%;
    left: 100%;
    transform: rotate(-135deg) translate(-6px, -5px);
  }

  .d3-tip.nw:after {
    transform: rotate(-135deg) translate(-3px, -4px);
  }

  /* South */
  .d3-tip.s:before, .d3-tip.s:after {
    top: 0%;
    left: 50%;
    transform: rotate(90deg) translate(-10px, -5px);
  }

  .d3-tip.s:after {
    transform: rotate(90deg) translate(-7px, -4px);
  }

  /* South east */
  .d3-tip.se:before, .d3-tip.se:after {
    top: 0%;
    left: 0%;
    transform: rotate(45deg) translate(-6px, -5px);
  }

  .d3-tip.se:after {
    transform: rotate(45deg) translate(-3px, -4px);
  }

  /* South west */
  .d3-tip.sw:before, .d3-tip.sw:after {
    top: 0%;
    left: 100%;
    transform: rotate(135deg) translate(-6px, -5px);
  }

  .d3-tip.sw:after {
    transform: rotate(135deg) translate(-3px, -4px);
  }

  /* Style tip content */
  .d3-tip-content {
    white-space: nowrap;
    font-family: Verdana, sans-serif;
    font-size: .9em;
    text-align: left;
  }
</style>

<script>
"use strict";

document.addEventListener("DOMContentLoaded", function() {
  /******************************************************* Declare variables *******************************************************/

  // Static data variables
  const SVG_ID = "split-radar"; // ID of SVG element
  const SAMPLE_MESSAGE = {
    version: "1",
    resultName: "dd395",
    rowCount: 18,
    availableRowCount: 18,
    data: [
      ["Hybrid", "Cool Factor", 3, "BEST12.", "Split", 1],
      ["Hybrid", "Cost Efficiency", 6, "BEST12.", "Split", 1],
      ["Hybrid", "Utility", 3, "BEST12.", "Split", 1],
      ["Sedan", "Cool Factor", 4, "BEST12.", "Split", 1],
      ["Sedan", "Cost Efficiency", 4, "BEST12.", "Split", 1],
      ["Sedan", "Utility", 2, "BEST12.", "Split", 1],
      ["Sports", "Cool Factor", 6, "BEST12.", "Single", 0],
      ["Sports", "Cost Efficiency", 3, "BEST12.", "Single", 0],
      ["Sports", "Utility", 1, "BEST12.", "Single", 0],
      ["SUV", "Cool Factor", 2, "BEST12.", "Single", 0],
      ["SUV", "Cost Efficiency", 1, "BEST12.", "Single", 0],
      ["SUV", "Utility", 5, "BEST12.", "Single", 0],
      ["Truck", "Cool Factor", 1, "BEST12.", "Split", 1],
      ["Truck", "Cost Efficiency", 2, "BEST12.", "Split", 1],
      ["Truck", "Utility", 6, "BEST12.", "Split", 1],
      ["Wagon", "Cool Factor", 5, "BEST12.", "Single", 0],
      ["Wagon", "Cost Efficiency", 5, "BEST12.", "Single", 0],
      ["Wagon", "Utility", 4, "BEST12.", "Single", 0]
    ],
    columns: [
      {
        name: "bi694",
        label: "Type",
        type: "string"
      },
      {
        name: "bi695",
        label: "Metric",
        type: "string"
      },
      {
        name: "bi696",
        label: "Measure",
        type: "number",
        usage: "quantitative",
        aggregation: "sum",
        format: {
          name: "BEST",
          width: 12,
          precision: 0,
          formatString: "BEST12."
        }
      },
      {
        name: "bi697",
        label: "Format",
        type: "string"
      },
      {
        name: "bi698",
        label: "View",
        type: "string"
      },
      {
        name: "ri1",
        type: "number",
        usage: "brush",
        format: {
          name: "COMMA",
          width: 12,
          precision: 2,
          formatString: "COMMA12.2"
        }
      }
    ]
  }; // Sample data message to render graph outside of VA for debugging
  const OPACITY = {
    fill: {
      focus: 0.6,
      default: 0.2,
      unfocus: 0.1
    },
    stroke: {
      focus: 1,
      default: 0.6,
      unfocus: 0.2
    }
  }; // Various opacity values used during rendering
  const MEASURE_MAXIMUM = 6; // Maximum possible value for measures

  // Dynamic data variables
  let VA_MESSAGE; // Data message to be received from VA
  let VA_RESULT_NAME; // Result name required to send messages back to VA
  let SPLIT; // Boolean indicating whether graph should be rendered in split mode
  let DATA; // Data to be parsed from VA data message
  let OLD_DATA; // Data from previous render to track duplicate point
  let METADATA = []; // Metadata to be parsed from VA data message
  let OLD_METADATA; // Metadata from previous render to track duplicate point
  let SELECTED_CATEGORY; // Currently selected category
  let LAST_TRANSITION_END = Date.now(); // Time of last transition used to time transition callbacks

  // Static dimension variables
  const TRANS_TIME = 500; // Duration of major transitions
  const TRANS_DELAY = 20; // Small buffer to ensure all callbacks have finished before allowing new transition
  const HOVER_TRANS_TIME = 100; // Duration of focus transitions
  const ENTER_REMOVE_TRANS_TIME = 200; // Duration of enter and exit transitions for data points and grid lines
  const TILE_MIN_WIDTH = 150; // Minimum width for a graph tile
  const TILE_MIN_HEIGHT = 150; // Minimim height for a graph tile
  const MEASURE_LABEL_PADDING = 10; // Padding between edge of radar chart and measure labels

  // Dynamic dimension variables
  let WIDTH; // Width of SVG element
  let HEIGHT; // Height of SVG element
  let GRID_WIDTH; // Total width of all graph tiles
  let GRID_HEIGHT; // Total height of all graph tiles
  let TILE_WIDTH; // Width of graph tile
  let TILE_HEIGHT; // Height of graph tile
  let RADIUS; // Radius of radar chart
  let OLD_RADIUS; // Previous radius of chart used for tweening height changes
  let DELTA_ANGLE; // Angle in radians between each measure on circle
  let TOP_PAD; // Vertical padding for measure labels
  let SIDE_PAD; // Horizontal padding for measure labels

  // Selection and d3 variables
  d3.selection.prototype.moveToFront = function() {
    return this.each(function() {
      this.parentNode.appendChild(this);
    });
  }; // Bring element to front of SVG (from https://github.com/wbkd/d3-extended)
  let SVG; // SVG selection
  let CATEGORY_GROUPS; // Category groups data-join
  let GRID_LINES; // Grid lines data-join
  let GRID_CIRCLES; // Grid circles data-join
  let MEASURE_LABELS; // Measure labels data-join
  let DATA_PATHS; // Data paths data-join
  let DATA_POINTS; // Data points data-join

  // Legend variables
  const LEG = {
    topPad: 20, // Padding between chart and legend title
    titlePad: 5, // Padding between legend title bottom and first row of legend
    rowPad: 3, // Padding between legend rows
    rectWidth: 12, // Width of legend rects
    rectPad: 5, // Padding between legend rect and legend text
    textPad: 5, // Padding after legend text
    title: undefined, // Title of legend
    data: undefined, // Array of strings for legend entries
    elPos: undefined, // Positions of legend text elements
    height: undefined, // Height allocated for legend,
    groupSelection: undefined, // Legend group selection
    titleDataJoin: undefined, // Legend title data-join
    groupDataJoin: undefined // Legend group data-join (group contains rect and text elements)
  };

  // Tooltip variables
  const TIP = {
    self: undefined, // Tooltip object
    dir: "n" // Tooltip direction
  };

  // Gradient variables
  const GRAD = {
    fill: {
      Hybrid: "#21b9b7",
      Sedan: "#4141e0",
      Sports: "#7db71a",
      SUV: "#8e2f8a",
      Truck: "#d38506",
      Wagon: "#0abf85"
    }, // Fill colors by key
    stroke: {
      Hybrid: "#1d9992",
      Sedan: "#2222bc",
      Sports: "#6a9617",
      SUV: "#6d256d",
      Truck: "#ba7006",
      Wagon: "#0a9e69"
    }, // Stroke colors by key
    fillScale: d3.scaleOrdinal([
      "#21b9b7",
      "#4141e0",
      "#7db71a",
      "#8e2f8a",
      "#d38506",
      "#0abf85",
      "#2f90ec",
      "#db3851",
      "#61F9F7",
      "#8181FF",
      "#BDF75A",
      "#CE6FCA",
      "#FFC546",
      "#4AFFC5",
      "#6FD0FF",
      "#FF7891",
      "#007977",
      "#0101A0",
      "#3D7700",
      "#4E004A",
      "#934500",
      "#007F45",
      "#0050AC",
      "#9B0011"
    ]), // Backup ordinal scale for fills
    strokeScale: d3.scaleOrdinal([
      "#1d9992",
      "#2222bc",
      "#6a9617",
      "#6d256d",
      "#ba7006",
      "#0a9e69",
      "#07689e",
      "#a50a2f",
      "#5DD9D2",
      "#6262FC",
      "#AAD657",
      "#AD65AD",
      "#FAB046",
      "#4ADEA9",
      "#47A8DE",
      "#E54A6F",
      "#005952",
      "#00007C",
      "#2A5600",
      "#2D002D",
      "#7A3000",
      "#005E29",
      "#00285E",
      "#650000"
    ]), // Backup ordinal scale for strokes
    data: undefined, // Array of keys and ids used to create gradients
    defsSelection: undefined, // Defs selections
    gradsDataJoin: undefined // Gradients data join
  };

  /*************************************************** Setup Callback Functions ***************************************************/

  // Attach event for data message from VA
  va.messagingUtil.setOnDataReceivedCallback(handleCallback);

  // If not being rendered in iFrame (outside VA), render with sample data
  if (!inIframe()) {
    onDataReceived(SAMPLE_MESSAGE);
  }

  // Listen for resize event
  va.contentUtil.setupResizeListener(drawElements);

  /****************************************************** Callback Functions ******************************************************/

  // Use timeouts to debounce update events
  function handleCallback(messageFromVA) {
    if (LAST_TRANSITION_END > Date.now()) {
      setTimeout(function() {
        onDataReceived(messageFromVA);
      }, LAST_TRANSITION_END - Date.now());
      LAST_TRANSITION_END = LAST_TRANSITION_END + TRANS_TIME + TRANS_DELAY;
    } else {
      onDataReceived(messageFromVA);
      LAST_TRANSITION_END = Date.now() + TRANS_TIME + TRANS_DELAY;
    }
  }

  // Take action on received data
  function onDataReceived(messageFromVA) {
    // Initialize data variables
    VA_MESSAGE = messageFromVA;
    VA_RESULT_NAME = messageFromVA.resultName;

    // Validate data roles
    if (
      !va.contentUtil.validateRoles(messageFromVA, [
        "string",
        "string",
        "number",
        "string",
        "string",
        "number"
      ])
    ) {
      va.messagingUtil.postInstructionalMessage(
        VA_RESULT_NAME,
        "D3 Radar Chart expects columns to be assigned in this order:\n" +
          " 1. Category (string)\n" +
          " 2. Metric (string)\n" +
          " 3. Measure (number)\n" +
          " 4. Format (string)\n" +
          " 5. View (string)\n" +
          " 6. View Selection (from linked selection) (number)"
      );
      return;
    }

    // Determine whether or not radar should be split based on selection
    SPLIT =
      (VA_MESSAGE.data[0][4] == "Split" && VA_MESSAGE.data[0][5] == 1) ||
      (VA_MESSAGE.data[0][4] == "Single" && VA_MESSAGE.data[0][5] == 0);

    // Create nest to help process tall data structure
    const nestedData = d3
      .nest()
      .key(function(d) {
        return d[1];
      })
      .entries(VA_MESSAGE.data);
    const numMeasures = nestedData.length;

    // Restructure metadata from data message
    OLD_METADATA = METADATA;
    DELTA_ANGLE = (2 * Math.PI) / numMeasures;

    METADATA = {
      category: VA_MESSAGE.columns[0].label,
      metrics: {}
    };

    for (let i = 0; i < numMeasures; i++) {
      METADATA.metrics[nestedData[i].key] = {
        metric: nestedData[i].key,
        angle: i * DELTA_ANGLE,
        format: translateFormat(VA_MESSAGE.data[i][3]),
        maximum: d3.max(VA_MESSAGE.data, function(d) {
          if (d[1] == nestedData[i].key) {
            return d[2];
          } else {
            return Number.MIN_VALUE;
          }
        })
      };
    }

    // Restructure data from 2d array to array of objects
    let datum, metric;
    OLD_DATA = DATA;
    DATA = [];
    for (let i = 0; i < VA_MESSAGE.data.length / numMeasures; i++) {
      // Iterate over each category
      datum = {
        category: VA_MESSAGE.data[i * numMeasures][0],
        id: "id-" +  VA_MESSAGE.data[i * numMeasures][0].replace(/[\W]/g, "_"),
        metrics: []
      };

      for (let j = 0; j < numMeasures; j++) {
        // Iterate over  metrics
        metric = {
          category: datum.category,
          metric: VA_MESSAGE.data[i * numMeasures + j][1],
          measure: VA_MESSAGE.data[i * numMeasures + j][2],
          scaledMeasure:
            VA_MESSAGE.data[i * numMeasures + j][2] / MEASURE_MAXIMUM
        };

        datum.metrics.push(metric);
      }

      DATA.push(datum);
    }

    // Assign data variables for legend
    LEG.title = METADATA.category;
    LEG.data = DATA.map(function(d) {
      return {
        key: d.category,
        id: d.id
      };
    });

    // Assign data variable for gradients
    GRAD.data = LEG.data;

    // Initialize chart if first draw, otherwise process data and update elements accordingly
    if (d3.select("#" + SVG_ID).empty()) {
      drawElements();
    } else {
      updateElements();
    }
  }

  // Draw elements for first time and on resize event
  function drawElements() {
    // Return if data is not yet initialized
    if (!DATA) {
      return;
    }

    // Calculate dimensions for graph based on container dimensions
    WIDTH = document.body.clientWidth;
    HEIGHT = document.body.clientHeight;

    // Append svg and save reference
    d3.select("body")
      .selectAll("#" + SVG_ID)
      .data([DATA])
      .enter()
      .append("svg")
      .attr("id", SVG_ID)
      .on("click", legendDeselectAll)
      .each(function() {
        // Initialize tooltip
        TIP.self = d3
          .tip()
          .attr("class", "d3-tip")
          .offset([-8, 0])
          .html(function(d) {
            return (
              "<table class='d3-tip-content'> <tr> <td> " +
              METADATA.category +
              ":\t</td> <td>" +
              d.category +
              "</td> </tr>" +
              "<tr> <td> " +
              d.metric +
              ":\t</td> <td>" +
              METADATA.metrics[d.metric].format(d.measure) +
              "</td> </tr> </table>"
            );
          });

        d3.select(this).call(TIP.self);
      });

    SVG = d3.select("#" + SVG_ID);

    // Append defs and save reference
    SVG.selectAll(".gradient-defs")
      .data([DATA])
      .enter()
      .append("defs")
      .classed("gradient-defs", true);

    GRAD.defsSelection = SVG.select(".gradient-defs");

    // Create gradient definitions
    defineGradients();

    // Calculate padding to prevent measure labels from being cutoff
    calculatePadding();

    // Compute the x y locations for legend elements
    calculateLegendDimensions();

    // Create grids if in split mode
    if (SPLIT) {
      gridify();
    }

    // Draw legend elements
    drawLegend();

    // Compute radius using above dimensions
    OLD_RADIUS = RADIUS;
    RADIUS = SPLIT
      ? Math.min(TILE_WIDTH - 2 * SIDE_PAD, TILE_HEIGHT - 2 * TOP_PAD) / 2
      : Math.min(WIDTH - 2 * SIDE_PAD, HEIGHT - LEG.height - 2 * TOP_PAD) / 2;

    // Set SVG width/height using dimensions calculated above
    SVG.style("width", WIDTH).style("height", HEIGHT);

    // Create group for each category and create subelements within each group
    CATEGORY_GROUPS = SVG.selectAll(".g-category").data(DATA, function(d) {
      return d.category;
    });

    CATEGORY_GROUPS.enter()
      .append("g")
      .classed("g-category", true)
      .attr("id", function(d) {
        return "g-category-" + d.category;
      })
      .merge(CATEGORY_GROUPS)
      .attr("transform", function(d, i) {
        return SPLIT
          ? "translate(" +
              ((i % GRID_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2) +
              ", " +
              (TOP_PAD + Math.floor(i / GRID_WIDTH) * TILE_HEIGHT + RADIUS) +
              ")"
          : "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")";
      })
      .each(function(d, i) {
        let categoryGroup = this;
        let iCategory = i;

        // Create grid lines
        GRID_LINES = d3
          .select(categoryGroup)
          .selectAll(".grid-line")
          .data(Object.values(METADATA.metrics), function(d) {
            return d.metric;
          });

        GRID_LINES.enter()
          .append("line")
          .classed("grid-line", true)
          .attr("stroke", "#C4C4C4")
          .attr("data-angle", function(d) {
            return d.angle;
          })
          .attr("x1", 0)
          .attr("y1", 0)
          .merge(GRID_LINES)
          .attr("x2", function(d) {
            return RADIUS * Math.sin(d.angle);
          })
          .attr("y2", function(d) {
            return -RADIUS * Math.cos(d.angle);
          })
          .style("opacity", function() {
            return SPLIT || iCategory == 0 ? 1 : 0;
          });

        // Create grid circles
        GRID_CIRCLES = d3
          .select(categoryGroup)
          .selectAll(".grid-circle")
          .data([0.2, 0.4, 0.6, 0.8, 1]);

        GRID_CIRCLES.enter()
          .append("circle")
          .classed("grid-circle", true)
          .attr("fill", "none")
          .attr("stroke", "#E4E4E4")
          .attr("cx", 0)
          .attr("cy", 0)
          .merge(GRID_CIRCLES)
          .attr("r", function(d) {
            return d * RADIUS;
          })
          .style("opacity", function() {
            return SPLIT || iCategory == 0 ? 1 : 0;
          });

        // Create measure labels
        MEASURE_LABELS = d3
          .select(categoryGroup)
          .selectAll(".measure-label")
          .data(Object.values(METADATA.metrics), function(d) {
            return d.metric;
          });

        MEASURE_LABELS.enter()
          .append("text")
          .classed("measure-label", true)
          .text(function(d) {
            return d.metric;
          })
          .attr("data-angle", function(d) {
            return d.angle;
          })
          .attr("dx", function(d) {
            return d.angle == 0 || d.angle == Math.PI
              ? -this.getBBox().width / 2 + "px"
              : d.angle > 0 && d.angle < Math.PI
              ? 0 + "px"
              : -this.getBBox().width + "px";
          })
          .attr("dy", function(d) {
            return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
              ? -this.getBBox().height / 2 + "px"
              : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
              ? 0 + "px"
              : -this.getBBox().height + "px";
          })
          .merge(MEASURE_LABELS)
          .attr("x", function(d) {
            return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
          })
          .attr("y", function(d) {
            return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
          })
          .style("opacity", function() {
            return SPLIT || iCategory == 0 ? 1 : 0;
          });

        // Create data paths + data points
        DATA_PATHS = d3
          .select(categoryGroup)
          .selectAll(".data-path")
          .data([d], function(d) {
            return d.category;
          });

        DATA_PATHS.enter()
          .append("path")
          .classed("data-path", true)
          .attr("id", function(d) {
            return d.category + "-path";
          })
          .attr("fill", function(d) {
            return GRAD.fill[d.category]
              ? GRAD.fill[d.category]
              : GRAD.fillScale(d.category);
          })
          .attr("fill-opacity", function(d) {
            return getOpacity(d.category, OPACITY.fill);
          })
          .attr("stroke", function(d) {
            return GRAD.stroke[d.category]
              ? GRAD.stroke[d.category]
              : GRAD.strokeScale(d.category);
          })
          .attr("stroke-opacity", function(d) {
            return getOpacity(d.category, OPACITY.stroke);
          })
          .merge(DATA_PATHS)
          .attr("d", function(d) {
            const dPath = d;
            const points = [];
            let path = "M ";
            let x, y;
            for (let j = 0; j < dPath.metrics.length; j++) {
              x =
                RADIUS *
                dPath.metrics[j].scaledMeasure *
                Math.sin(j * DELTA_ANGLE);
              y =
                -RADIUS *
                dPath.metrics[j].scaledMeasure *
                Math.cos(j * DELTA_ANGLE);
              points.push({
                category: dPath.category,
                metric: dPath.metrics[j].metric,
                measure: dPath.metrics[j].measure,
                scaledMeasure: dPath.metrics[j].scaledMeasure,
                x: x,
                y: y
              });

              path +=
                x + "," + y + (j == dPath.metrics.length - 1 ? " Z" : " L ");
            }

            DATA_POINTS = d3
              .select(categoryGroup)
              .selectAll(".data-point")
              .filter(function(d) {
                return dPath.category == d.category;
              })
              .data(points, function(d) {
                return d.metric;
              });

            DATA_POINTS.enter()
              .append("circle")
              .classed("data-point", true)
              .attr(
                "fill",
                GRAD.stroke[dPath.category]
                  ? GRAD.stroke[dPath.category]
                  : GRAD.strokeScale(dPath.category)
              )
              .attr("fill-opacity", getOpacity(dPath.category, OPACITY.stroke))
              .on("mouseover", function(d) {
                // Assign direction and show tooltip
                TIP.self
                  .direction("n")
                  .offset([-8, 0])
                  .show(d, this)
                  .direction(getTipDirection())
                  .offset(getTipOffset())
                  .show(d, this);
              })
              .on("mouseout", TIP.self.hide)
              .merge(DATA_POINTS)
              .attr("cx", function(d) {
                return d.x;
              })
              .attr("cy", function(d) {
                return d.y;
              })
              .attr("r", 4);

            return path;
          });
      });

    // Move tooltip if present
    d3.select(".tip")
      .style("top", function() {
        return RADIUS + TOP_PAD - this.height / 2 + "px";
      })
      .style("left", function() {
        return WIDTH / 2 - this.width / 2 + "px";
      });
  }

  // Redraw data dependent elements on data change
  function updateElements() {
    // Update dimension since a split enter/exit can change graph dimensions
    WIDTH = document.body.clientWidth;
    HEIGHT = document.body.clientHeight;

    // Calculate padding to prevent measure labels from being cutoff
    calculatePadding();

    // Create gradient definitions
    defineGradients();

    // Compute the x y locations for legend elements
    calculateLegendDimensions();

    // Create grids if in split mode
    if (SPLIT) {
      gridify();
    }

    // Update legend elements
    updateLegend();

    // Compute radius using above dimensions
    OLD_RADIUS = RADIUS;
    RADIUS = SPLIT
      ? Math.min(TILE_WIDTH - 2 * SIDE_PAD, TILE_HEIGHT - 2 * TOP_PAD) / 2
      : Math.min(WIDTH - 2 * SIDE_PAD, HEIGHT - LEG.height - 2 * TOP_PAD) / 2;

    // Set SVG width/height using dimensions calculated above
    SVG.style("width", WIDTH).style("height", HEIGHT);

    // Update category groups and all subelements
    CATEGORY_GROUPS = SVG.selectAll(".g-category").data(DATA, function(d) {
      return d.category;
    });

    CATEGORY_GROUPS.enter()
      .append("g")
      .classed("g-category", true)
      .attr("id", function(d) {
        return "g-category-" + d.category;
      })
      .attr("transform", function(d, i) {
        return SPLIT
          ? "translate(" +
              ((i % GRID_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2) +
              ", " +
              (TOP_PAD + Math.floor(i / GRID_WIDTH) * TILE_HEIGHT + RADIUS) +
              ")"
          : "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")";
      })
      .each(function(d, i) {
        let categoryGroup = d3.select(this);
        let iCategory = i;

        // Enter grid lines
        GRID_LINES = categoryGroup
          .selectAll(".grid-line")
          .data(Object.values(METADATA.metrics), function(d) {
            return d.metric;
          });

        GRID_LINES.enter()
          .append("line")
          .classed("grid-line", true)
          .attr("stroke", "#C4C4C4")
          .attr("data-angle", function(d) {
            return d.angle;
          })
          .attr("x1", 0)
          .attr("y1", 0)
          .attr("x2", function(d) {
            return RADIUS * Math.sin(d.angle);
          })
          .attr("y2", function(d) {
            return -RADIUS * Math.cos(d.angle);
          })
          .style("opacity", 0)
          .transition()
          .duration(TRANS_TIME)
          .style("opacity", function() {
            return SPLIT || iCategory == 0 ? 1 : 0;
          });

        // Enter grid circles
        GRID_CIRCLES = categoryGroup
          .selectAll(".grid-circle")
          .data([0.2, 0.4, 0.6, 0.8, 1]);

        GRID_CIRCLES.enter()
          .append("circle")
          .classed("grid-circle", true)
          .attr("fill", "none")
          .attr("stroke", "#E4E4E4")
          .attr("cx", 0)
          .attr("cy", 0)
          .merge(GRID_CIRCLES)
          .attr("r", function(d) {
            return d * RADIUS;
          })
          .style("opacity", 0)
          .transition()
          .duration(TRANS_TIME)
          .style("opacity", function() {
            return SPLIT || iCategory == 0 ? 1 : 0;
          });

        // Enter measure labels
        MEASURE_LABELS = categoryGroup
          .selectAll(".measure-label")
          .data(Object.values(METADATA.metrics), function(d) {
            return d.metric;
          });

        MEASURE_LABELS.enter()
          .append("text")
          .classed("measure-label", true)
          .text(function(d) {
            return d.metric;
          })
          .attr("dx", function(d) {
            return d.angle == 0 || d.angle == Math.PI
              ? -this.getBBox().width / 2 + "px"
              : d.angle > 0 && d.angle < Math.PI
              ? 0 + "px"
              : -this.getBBox().width + "px";
          })
          .attr("dy", function(d) {
            return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
              ? -this.getBBox().height / 2 + "px"
              : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
              ? 0 + "px"
              : -this.getBBox().height + "px";
          })
          .attr("x", function(d) {
            return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
          })
          .attr("y", function(d) {
            return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
          })
          .style("opacity", 0)
          .transition()
          .duration(TRANS_TIME)
          .style("opacity", function() {
            return SPLIT || iCategory == 0 ? 1 : 0;
          });

        // Enter data paths + data points (Make all points start from 0,0 and go to appropriate location while fading in)
        DATA_PATHS = categoryGroup
          .selectAll(".data-path")
          .data([d], function(d) {
            return d.category;
          });

        DATA_PATHS.enter()
          .append("path")
          .classed("data-path", true)
          .attr("id", function(d) {
            return d.category + "-path";
          })
          .attr("fill", function(d) {
            return GRAD.fill[d.category]
              ? GRAD.fill[d.category]
              : GRAD.fillScale(d.category);
          })
          .attr("fill-opacity", function(d) {
            return getOpacity(d.category, OPACITY.fill);
          })
          .attr("stroke", function(d) {
            return GRAD.stroke[d.category]
              ? GRAD.stroke[d.category]
              : GRAD.strokeScale(d.category);
          })
          .attr("stroke-opacity", function(d) {
            return getOpacity(d.category, OPACITY.stroke);
          })
          .attr("d", function(d) {
            // Generate actual points while placing path at 0,0
            const dPath = d;
            const points = [];
            let x, y;
            let path = "M ";
            for (let j = 0; j < d.metrics.length; j++) {
              path += "0,0" + (j == d.metrics.length - 1 ? " Z" : " L ");

              x =
                RADIUS *
                dPath.metrics[j].scaledMeasure *
                Math.sin(j * DELTA_ANGLE);
              y =
                -RADIUS *
                dPath.metrics[j].scaledMeasure *
                Math.cos(j * DELTA_ANGLE);
              points.push({
                category: dPath.category,
                metric: dPath.metrics[j].metric,
                measure: dPath.metrics[j].measure,
                scaledMeasure: dPath.metrics[j].scaledMeasure,
                x: x,
                y: y
              });
            }

            DATA_POINTS = categoryGroup
              .selectAll(".data-point")
              .filter(function(d) {
                return dPath.category == d.category;
              })
              .data(points, function(d) {
                return d.metric;
              });

            DATA_POINTS.enter()
              .append("circle")
              .classed("data-point", true)
              .attr("fill", function(d) {
                return GRAD.stroke[d.category]
                  ? GRAD.stroke[d.category]
                  : GRAD.strokeScale(d.category);
              })
              .attr("fill-opacity", getOpacity(dPath.category, OPACITY.stroke))
              .on("mouseover", function(d) {
                // Assign direction and show tooltip
                TIP.self
                  .direction("n")
                  .offset([-8, 0])
                  .show(d, this)
                  .direction(getTipDirection())
                  .offset(getTipOffset())
                  .show(d, this);
              })
              .on("mouseout", TIP.self.hide)
              .attr("cx", 0)
              .attr("cy", 0)
              .attr("r", 4)
              .style("opacity", 0);

            return path;
          })
          .style("opacity", 0)
          .transition()
          .duration(TRANS_TIME)
          .style("opacity", 1)
          .attr("d", function(d) {
            const dPath = d;
            const points = [];
            let path = "M ";
            let x, y;
            for (let j = 0; j < dPath.metrics.length; j++) {
              x =
                RADIUS *
                dPath.metrics[j].scaledMeasure *
                Math.sin(j * DELTA_ANGLE);
              y =
                -RADIUS *
                dPath.metrics[j].scaledMeasure *
                Math.cos(j * DELTA_ANGLE);
              points.push({
                category: dPath.category,
                metric: dPath.metrics[j].metric,
                measure: dPath.metrics[j].measure,
                scaledMeasure: dPath.metrics[j].scaledMeasure,
                x: x,
                y: y
              });

              path +=
                x + "," + y + (j == dPath.metrics.length - 1 ? " Z" : " L ");
            }

            // Transition data points from 0,0 to proper locations
            categoryGroup
              .selectAll(".data-point")
              .filter(function(d) {
                return dPath.category == d.category;
              })
              .transition()
              .duration(TRANS_TIME)
              .attr("cx", function(d) {
                return d.x;
              })
              .attr("cy", function(d) {
                return d.y;
              })
              .style("opacity", 1);

            return path;
          });
      });

    CATEGORY_GROUPS.each(function(d, i) {
      let categoryGroup = this;
      let iCategory = i;

      // Update grid lines
      GRID_LINES = d3
        .select(categoryGroup)
        .selectAll(".grid-line")
        .data(Object.values(METADATA.metrics), function(d) {
          return d.metric;
        });

      GRID_LINES.enter()
        .append("line")
        .classed("grid-line", true)
        .attr("stroke", "#C4C4C4")
        .attr("data-angle", function(d) {
          return d.angle;
        })
        .attr("x1", 0)
        .attr("y1", 0)
        .attr("x2", function(d) {
          return RADIUS * Math.sin(d.angle);
        })
        .attr("y2", function(d) {
          return -RADIUS * Math.cos(d.angle);
        })
        .style("opacity", 0)
        .transition()
        .delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME)
        .duration(ENTER_REMOVE_TRANS_TIME)
        .style("opacity", function() {
          return SPLIT || iCategory == 0 ? 1 : 0;
        });

      GRID_LINES.transition()
        .duration(TRANS_TIME)
        .style("opacity", function() {
          return SPLIT || iCategory == 0 ? 1 : 0;
        })
        .attrTween("x2", function(d) {
          const startAngle = OLD_METADATA.metrics[d.metric].angle;
          return xTween(OLD_RADIUS, RADIUS, startAngle, d.angle);
        })
        .attrTween("y2", function(d) {
          const startAngle = OLD_METADATA.metrics[d.metric].angle;
          return yTween(OLD_RADIUS, RADIUS, startAngle, d.angle);
        });

      GRID_LINES.exit()
        .transition()
        .duration(ENTER_REMOVE_TRANS_TIME)
        .style("opacity", 0)
        .remove();

      // Update grid circles
      GRID_CIRCLES = d3.select(categoryGroup).selectAll(".grid-circle");

      GRID_CIRCLES.transition()
        .duration(TRANS_TIME)
        .style("opacity", function() {
          return SPLIT || iCategory == 0 ? 1 : 0;
        })
        .attr("r", function(d) {
          return d * RADIUS;
        });

      // Update measure labels
      MEASURE_LABELS = d3
        .select(categoryGroup)
        .selectAll(".measure-label")
        .data(Object.values(METADATA.metrics), function(d) {
          return d.metric;
        });

      MEASURE_LABELS.enter()
        .append("text")
        .classed("measure-label", true)
        .text(function(d) {
          return d.metric;
        })
        .attr("dx", function(d) {
          return d.angle == 0 || d.angle == Math.PI
            ? -this.getBBox().width / 2 + "px"
            : d.angle > 0 && d.angle < Math.PI
            ? 0 + "px"
            : -this.getBBox().width + "px";
        })
        .attr("dy", function(d) {
          return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
            ? -this.getBBox().height / 2 + "px"
            : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
            ? 0 + "px"
            : -this.getBBox().height + "px";
        })
        .attr("x", function(d) {
          return (RADIUS + MEASURE_LABEL_PADDING) * Math.sin(d.angle);
        })
        .attr("y", function(d) {
          return -(RADIUS + MEASURE_LABEL_PADDING) * Math.cos(d.angle);
        })
        .style("opacity", 0)
        .transition()
        .duration(TRANS_TIME)
        .style("opacity", function() {
          return SPLIT || iCategory == 0 ? 1 : 0;
        });

      MEASURE_LABELS.transition()
        .duration(TRANS_TIME)
        .style("opacity", function() {
          return SPLIT || iCategory == 0 ? 1 : 0;
        })
        .attr("dx", function(d) {
          return d.angle == 0 || d.angle == Math.PI
            ? -this.getBBox().width / 2 + "px"
            : d.angle > 0 && d.angle < Math.PI
            ? 0 + "px"
            : -this.getBBox().width + "px";
        })
        .attr("dy", function(d) {
          return d.angle == Math.PI / 2 || d.angle == (3 * Math.PI) / 2
            ? -this.getBBox().height / 2 + "px"
            : d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2
            ? 0 + "px"
            : -this.getBBox().height + "px";
        })
        .attrTween("x", function(d) {
          const startAngle = OLD_METADATA.metrics[d.metric].angle;
          return xTween(
            OLD_RADIUS + MEASURE_LABEL_PADDING,
            RADIUS + MEASURE_LABEL_PADDING,
            startAngle,
            d.angle
          );
        })
        .attrTween("y", function(d) {
          const startAngle = OLD_METADATA.metrics[d.metric].angle;
          return yTween(
            OLD_RADIUS + MEASURE_LABEL_PADDING,
            RADIUS + MEASURE_LABEL_PADDING,
            startAngle,
            d.angle
          );
        });

      MEASURE_LABELS.exit()
        .transition()
        .duration(ENTER_REMOVE_TRANS_TIME)
        .style("opacity", 0)
        .remove();

      // Update data paths and points
      DATA_PATHS = d3
        .select(categoryGroup)
        .selectAll(".data-path")
        .data([d], function(d) {
          return d.category;
        });

      DATA_PATHS.attr("fill", function(d) {
        return GRAD.fill[d.category]
          ? GRAD.fill[d.category]
          : GRAD.fillScale(d.category);
      })
        .attr("stroke", function(d) {
          return GRAD.stroke[d.category]
            ? GRAD.stroke[d.category]
            : GRAD.strokeScale(d.category);
        })
        .each(function(d) {
          // Find where point was entered/removed and add duplicate point for entered point
          const oldMetrics = Object.values(OLD_METADATA.metrics);
          const metrics = Object.values(METADATA.metrics);
          const oldDelta = Object.values(OLD_METADATA.metrics)[1]
            ? Object.values(OLD_METADATA.metrics)[1].angle
            : Math.PI;
          const length = Math.max(oldMetrics.length, metrics.length);
          d.entered = oldMetrics.length < metrics.length;

          // Find where point was added or removed
          for (let j = 0; j < length; j++) {
            if (
              !oldMetrics[j] ||
              !metrics[j] ||
              oldMetrics[j].metric != metrics[j].metric
            ) {
              d.changedIndex = j;
              break;
            }
          }

          // If a point was entered, traverse old data and add duplicate point at entered index
          if (d.entered) {
            d3.select(this).attr("d", function(d) {
              const oldData = OLD_DATA[iCategory].metrics;
              let path =
                d.changedIndex == 0
                  ? "M " + "0," + -RADIUS * oldData[0].scaledMeasure + " L "
                  : "M ";
              let x, y;
              for (let j = 0; j < oldData.length; j++) {
                if (d.changedIndex == j + 1) {
                  x =
                    RADIUS * oldData[j].scaledMeasure * Math.sin(j * oldDelta);
                  y =
                    -RADIUS * oldData[j].scaledMeasure * Math.cos(j * oldDelta);

                  path += x + "," + y + " L ";
                }

                x = RADIUS * oldData[j].scaledMeasure * Math.sin(j * oldDelta);
                y = -RADIUS * oldData[j].scaledMeasure * Math.cos(j * oldDelta);

                path += x + "," + y + (j == oldData.length - 1 ? " Z" : " L ");
              }
              return path;
            });
          }
        })
        .transition()
        .duration(TRANS_TIME)
        .attr("d", function(d) {
          // Transition data path to new set of points
          const dPath = d;
          const points = [];
          let path = "M ";
          let x, y;
          for (let j = 0; j < dPath.metrics.length; j++) {
            if (
              (!d.entered && d.changedIndex == j) ||
              (j == dPath.metrics.length - 1 &&
                d.changedIndex == dPath.metrics.length)
            ) {
              // If point was removed create a duplicate for transition
              x =
                RADIUS *
                dPath.metrics[j % dPath.metrics.length].scaledMeasure *
                Math.sin((j % dPath.metrics.length) * DELTA_ANGLE);
              y =
                -RADIUS *
                dPath.metrics[j % dPath.metrics.length].scaledMeasure *
                Math.cos((j % dPath.metrics.length) * DELTA_ANGLE);

              path += x + "," + y + " L ";
            }

            x =
              RADIUS *
              dPath.metrics[j].scaledMeasure *
              Math.sin(j * DELTA_ANGLE);
            y =
              -RADIUS *
              dPath.metrics[j].scaledMeasure *
              Math.cos(j * DELTA_ANGLE);
            points.push({
              category: dPath.category,
              metric: dPath.metrics[j].metric,
              measure: dPath.metrics[j].measure,
              scaledMeasure: dPath.metrics[j].scaledMeasure,
              x: x,
              y: y
            });

            path +=
              x + "," + y + (j == dPath.metrics.length - 1 ? " Z" : " L ");
          }

          // Update data points for current category using points array generated above
          DATA_POINTS = d3
            .select(categoryGroup)
            .selectAll(".data-point")
            .filter(function(d) {
              return dPath.category == d.category;
            })
            .data(points, function(d) {
              return d.metric;
            });

          DATA_POINTS.attr(
            "fill",
            GRAD.stroke[dPath.category]
              ? GRAD.stroke[dPath.category]
              : GRAD.strokeScale(dPath.category)
          )
            .transition()
            .duration(TRANS_TIME)
            .attr("cx", function(d) {
              return d.x;
            })
            .attr("cy", function(d) {
              return d.y;
            });

          DATA_POINTS.enter()
            .append("circle")
            .classed("data-point", true)
            .attr(
              "fill",
              GRAD.stroke[dPath.category]
                ? GRAD.stroke[dPath.category]
                : GRAD.strokeScale(dPath.category)
            )
            .attr("fill-opacity", getOpacity(dPath.category, OPACITY.stroke))
            .attr("cx", function(d) {
              return d.x;
            })
            .attr("cy", function(d) {
              return d.y;
            })
            .attr("r", 4)
            .style("opacity", 0)
            .on("mouseover", function(d) {
              // Assign direction and show tooltip
              TIP.self
                .direction("n")
                .offset([-8, 0])
                .show(d, this)
                .direction(getTipDirection())
                .offset(getTipOffset())
                .show(d, this);
            })
            .on("mouseout", TIP.self.hide)
            .transition()
            .delay(TRANS_TIME - ENTER_REMOVE_TRANS_TIME)
            .duration(ENTER_REMOVE_TRANS_TIME)
            .style("opacity", 1);

          DATA_POINTS.exit()
            .transition()
            .duration(ENTER_REMOVE_TRANS_TIME)
            .style("opacity", 0)
            .remove();

          return path;
        })
        .on("end", function(d) {
          // Update data attributes and remove duplicate point if point was removed
          if (!d.entered) {
            d3.select(this).attr("d", function(d) {
              let path = "M ";
              let x, y;
              for (let j = 0; j < d.metrics.length; j++) {
                x =
                  RADIUS *
                  d.metrics[j].scaledMeasure *
                  Math.sin(j * DELTA_ANGLE);
                y =
                  -RADIUS *
                  d.metrics[j].scaledMeasure *
                  Math.cos(j * DELTA_ANGLE);

                path +=
                  x + "," + y + (j == d.metrics.length - 1 ? " Z" : " L ");
              }
              return path;
            });
          }
        });
    })
      .transition()
      .duration(TRANS_TIME)
      .attr("transform", function(d, i) {
        return SPLIT
          ? "translate(" +
              ((i % GRID_WIDTH) * TILE_WIDTH + TILE_WIDTH / 2) +
              ", " +
              (TOP_PAD + Math.floor(i / GRID_WIDTH) * TILE_HEIGHT + RADIUS) +
              ")"
          : "translate(" + WIDTH / 2 + ", " + (TOP_PAD + RADIUS) + ")";
      });

    CATEGORY_GROUPS.exit()
      .each(function() {
        let categoryGroup = d3.select(this);

        // Exit grid lines, grid circles, and measure labels
        categoryGroup
          .selectAll(".grid-line, .grid-circle, .measure-label")
          .transition()
          .duration(TRANS_TIME)
          .style("opacity", 0)
          .remove();

        // Exit data paths + data points (Make all points go to 0,0 and while fading out)
        categoryGroup
          .selectAll(".data-path")
          .each(function(d) {
            let dPath = d;

            categoryGroup
              .selectAll(".data-point")
              .filter(function(d) {
                return dPath.category == d.category;
              })
              .transition()
              .duration(TRANS_TIME)
              .attr("cx", 0)
              .attr("cy", 0)
              .style("opacity", 0)
              .remove();
          })
          .transition()
          .duration(TRANS_TIME)
          .attr("d", function(d) {
            let path = "M ";
            for (let j = 0; j < d.metrics.length; j++) {
              path += "0,0" + (j == d.metrics.length - 1 ? " Z" : " L ");
            }
            return path;
          })
          .style("opacity", 0)
          .remove();
      })
      .transition()
      .duration(TRANS_TIME)
      .remove();
  }

  /******************************************************* Helper Functions *******************************************************/

  // Determine whether or not page is being rendered in iFrame
  function inIframe() {
    try {
      return window.self !== window.top;
    } catch (e) {
      return true;
    }
  }

  // Calculate grid dimensions for split view that maximize room for each chart
  function gridify() {
    const factors = [];
    const n = DATA.length;
    let gridW, gridH, tileW, tileH, radius;

    // Determine possible width/height combinations to create grid
    for (let i = n; i > 0; i--) {
      gridW = i;
      gridH = Math.ceil(n / i);
      tileW = Math.max(WIDTH / gridW, TILE_MIN_WIDTH);
      tileH = Math.max((HEIGHT - LEG.height) / gridH, TILE_MIN_HEIGHT);
      radius = Math.min(tileW - 2 * SIDE_PAD, tileH - 2 * TOP_PAD) / 2;

      factors.push({
        gridW: gridW,
        gridH: gridH,
        tileW: tileW,
        tileH: tileH,
        radius: radius
      });
    }

    // Find width/height combination that maximizes radius
    let factor = factors[0];
    for (let i = 1; i < factors.length; i++) {
      if (factors[i].radius > factor.radius) {
        factor = factors[i];
      }
    }

    // Assign global dimensions using optimal width/height
    GRID_WIDTH = factor.gridW;
    GRID_HEIGHT = factor.gridH;
    TILE_WIDTH = Math.max(WIDTH / GRID_WIDTH, TILE_MIN_WIDTH);
    TILE_HEIGHT = Math.max(
      (HEIGHT - LEG.height) / GRID_HEIGHT,
      TILE_MIN_HEIGHT
    );
    WIDTH = GRID_WIDTH * TILE_WIDTH;
    HEIGHT = GRID_HEIGHT * TILE_HEIGHT + LEG.height;
  }

  // Determine coordinates for dynamic legend
  function calculateLegendDimensions() {
    // Create dummy text variable to get legend title height
    let titleHeight;
    SVG.append("text")
      .classed("legend-text", true)
      .text("TEST")
      .each(function() {
        titleHeight = this.getBBox().height;
        this.remove();
      });

    // Create dummy text variables to get legend text height/widths
    const textWidths = [];
    let textHeight;
    SVG.selectAll(".dummyText")
      .data(LEG.data)
      .enter()
      .append("text")
      .classed("legend-text", true)
      .text(function(d) {
        return d.key;
      })
      .style("font-weight", "bold")
      .each(function() {
        textHeight = this.getBBox().height;
        textWidths.push(this.getComputedTextLength());
        this.remove();
      });

    // Determine which row each element will sit in and how long each row is
    const rows = [];
    const rowSums = [];
    let rowSum;
    let row = 0;
    for (let i = 0; i < textWidths.length; i++) {
      rowSum = textWidths[i] + LEG.rectWidth + LEG.rectPad + LEG.textPad;
      rows.push(row);
      while (
        rowSum +
          textWidths[i + 1] +
          LEG.rectWidth +
          LEG.rectPad +
          LEG.textPad <=
          WIDTH &&
        i + 1 < textWidths.length
      ) {
        i++;
        rowSum += textWidths[i] + LEG.rectWidth + LEG.rectPad + LEG.textPad;
        rows.push(row);
      }
      rowSums.push(rowSum);
      row++;
    }

    // Calculate x and y coordinates for legend elements
    LEG.elPos = [];
    for (let i = 0; i < textWidths.length; i++) {
      LEG.elPos.push({
        x:
          i == 0 || rows[i - 1] != rows[i]
            ? WIDTH / 2 - rowSums[rows[i]] / 2
            : LEG.elPos[i - 1].x +
              textWidths[i - 1] +
              LEG.rectWidth +
              LEG.rectPad +
              LEG.textPad,
        y: titleHeight + LEG.titlePad + rows[i] * (textHeight + LEG.rowPad)
      });
    }

    // Set legend height
    LEG.height = LEG.elPos[LEG.elPos.length - 1].y + textHeight + LEG.rowPad;
  }

  // Draw legend elements using provided data
  function drawLegend() {
    // Append/update legend group and save reference
    SVG.selectAll(".g-legend")
      .data([LEG.title])
      .enter()
      .append("g")
      .classed("g-legend", true);

    LEG.groupSelection = SVG.select(".g-legend");

    // Create legend title
    LEG.titleDataJoin = LEG.groupSelection
      .selectAll(".legend-title")
      .data([LEG.title]);

    LEG.titleDataJoin
      .enter()
      .append("text")
      .classed("legend-title", true)
      .text(function(d) {
        return d;
      })
      .merge(LEG.titleDataJoin)
      .attr("transform", "translate(" + WIDTH / 2 + ", 0)");

    // Create legend groups
    LEG.groupDataJoin = LEG.groupSelection
      .selectAll(".g-legend-entry")
      .data(LEG.data, function(d) {
        return d.id;
      })
      .enter()
      .append("g")
      .classed("g-legend-entry", true)
      .attr("id", function(d) {
        return d.id + "-legend-entry";
      })
      .on("click", function(d, i) {
        legendSelect(d, i, this);
      });

    LEG.groupSelection
      .selectAll(".g-legend-entry")
      .data(LEG.data, function(d) {
        return d.id;
      })
      .attr("transform", function(d, i) {
        return "translate(" + LEG.elPos[i].x + ", " + LEG.elPos[i].y + ")";
      });

    // Append legend rects
    LEG.groupDataJoin
      .append("rect")
      .classed("legend-rect", true)
      .attr("width", LEG.rectWidth)
      .attr("height", LEG.rectWidth)
      .attr("fill", function(d) {
        return "url(#" + d.id + "-gradient)";
      })
      .attr("stroke", function(d) {
        return GRAD.stroke[d.key]
          ? GRAD.stroke[d.key]
          : GRAD.strokeScale(d.key);
      });

    // Append legend texts
    LEG.groupDataJoin
      .append("text")
      .classed("legend-text", true)
      .text(function(d) {
        return d.key;
      })
      .attr("x", LEG.rectWidth + LEG.rectPad)
      .attr("y", LEG.rectWidth / 2);

    // Position legend
    LEG.groupSelection.attr("transform", function() {
      return "translate(0, " + (HEIGHT - LEG.height) + ")";
    });
  }

  // Update legend on data change
  function updateLegend() {
    // Update legend groups
    LEG.groupDataJoin = LEG.groupSelection
      .selectAll(".g-legend-entry")
      .data(LEG.data, function(d) {
        return d.key;
      });

    // Exit
    LEG.groupDataJoin
      .exit()
      .each(function() {
        if (d3.select(this).classed("selected")) {
          legendDeselectAll();
        }
      })
      .transition()
      .duration(TRANS_TIME)
      .style("opacity", 0)
      .remove();

    // Update
    LEG.groupDataJoin
      .transition()
      .duration(TRANS_TIME)
      .attr("transform", function(d, i) {
        return "translate(" + LEG.elPos[i].x + ", " + LEG.elPos[i].y + ")";
      })
      .style("opacity", 1);

    // Enter
    let enter = LEG.groupDataJoin
      .enter()
      .append("g")
      .classed("g-legend-entry", true)
      .attr("id", function(d) {
        return d.id + "-legend-entry";
      })
      .attr("transform", function(d, i) {
        return "translate(" + LEG.elPos[i].x + ", " + LEG.elPos[i].y + ")";
      })
      .on("click", function(d, i) {
        legendSelect(d, i, this);
      });

    // Append legend rects
    enter
      .append("rect")
      .classed("legend-rect", true)
      .attr("width", LEG.rectWidth)
      .attr("height", LEG.rectWidth)
      .attr("fill", function(d) {
        return "url(#" + d.id + "-gradient)";
      })
      .attr("stroke", function(d) {
        return GRAD.stroke[d.key]
          ? GRAD.stroke[d.key]
          : GRAD.strokeScale(d.key);
      })
      .style("opacity", 0)
      .transition()
      .duration(TRANS_TIME)
      .style("opacity", 1);

    // Append legend texts
    enter
      .append("text")
      .classed("legend-text", true)
      .text(function(d) {
        return d.key;
      })
      .attr("x", LEG.rectWidth + LEG.rectPad)
      .attr("y", LEG.rectWidth / 2)
      .style("opacity", 0)
      .transition()
      .duration(TRANS_TIME)
      .style("opacity", 1);

    // Update legend position
    LEG.groupSelection
      .transition()
      .duration(TRANS_TIME)
      .attr("transform", function() {
        return "translate(0, " + (HEIGHT - LEG.height) + ")";
      });
  }

  // Determine direction for tooltip
  function getTipDirection() {
    const tip = d3.select(".d3-tip").node();
    const w = tip.clientWidth;
    const left = tip.offsetLeft;
    const top = tip.offsetTop;
    let dir;

    dir = top < 0 ? "s" : "n";

    if (left < 0) {
      dir += "e";
    } else if (left + w > WIDTH) {
      dir += "w";
    }
    TIP.dir = dir;
    return dir;
  }

  // Determine offset for tooltip based on direction
  function getTipOffset() {
    let offset;

    switch (TIP.dir) {
      case "n":
        offset = [-8, 0];
        break;
      case "ne":
        offset = [-5, 0];
        break;
      case "nw":
        offset = [-5, 0];
        break;
      case "s":
        offset = [8, 0];
        break;
      case "se":
        offset = [5, 0];
        break;
      case "sw":
        offset = [5, 0];
        break;
    }

    return offset;
  }

  // Create/update gradient definitions
  function defineGradients() {
    GRAD.gradsDataJoin = GRAD.defsSelection
      .selectAll(".gradient")
      .data(GRAD.data, function(d) {
        return d.id;
      });

    GRAD.gradsDataJoin
      .enter()
      .append("linearGradient")
      .classed("gradient", true)
      .attr("id", function(d) {
        return d.id + "-gradient";
      })
      .attr("x1", "0%")
      .attr("x2", "100%")
      .attr("y1", "50%")
      .attr("y2", "50%")
      .each(function(d) {
        // Append color stops
        d3.select(this)
          .append("stop")
          .attr("class", "start")
          .attr("offset", "0%")
          .attr("stop-color", function() {
            return GRAD.fill[d.key] ? GRAD.fill[d.key] : GRAD.fillScale(d.key);
          })
          .attr("stop-opacity", 1);

        d3.select(this)
          .append("stop")
          .attr("class", "end")
          .attr("offset", "100%")
          .attr("stop-color", function() {
            return GRAD.fill[d.key] ? GRAD.fill[d.key] : GRAD.fillScale(d.key);
          })
          .attr("stop-opacity", 0.7);
      });
  }

  // Calculate padding to prevent measure labels from being cutoff
  function calculatePadding() {
    // Create dummy text variable to get measure label widths and HEIGHT
    let height;
    let width = 0;
    SVG.selectAll(".dummyText")
      .data(Object.values(METADATA.metrics))
      .enter()
      .append("text")
      .classed("measure-label", true)
      .text(function(d) {
        return d.metric;
      })
      .each(function() {
        height = this.getBBox().height;
        width = Math.max(this.getComputedTextLength(), width);
        this.remove();
      });
    SIDE_PAD = width + 2 * MEASURE_LABEL_PADDING;
    TOP_PAD = height + 2 * MEASURE_LABEL_PADDING;
  }

  // Get opacity of data path and data points based on category
  function getOpacity(category, opacity) {
    return SELECTED_CATEGORY
      ? category == SELECTED_CATEGORY
        ? opacity.focus
        : opacity.unfocus
      : opacity.default;
  }

  // Translate SAS format to D3 format
  function translateFormat(formatString) {
    if (formatString.indexOf(".") == formatString.length - 1) formatString += 0;

    if (formatString.includes("DOLLAR"))
      return d3.format(
        formatString.replace("DOLLAR", "$").replace(".", ",.") + "f"
      );
    else if (formatString.includes("COMMA"))
      return d3.format(
        formatString.replace("COMMA", "").replace(".", ",.") + "f"
      );
    else if (formatString.includes("F"))
      return d3.format(formatString.replace("F", "") + "f");
    else if (formatString.includes("BEST"))
      return d3.format(formatString.replace("BEST", "") + "f");
    else if (formatString.includes("PERCENT"))
      return d3.format(
        formatString.replace("PERCENT", "").replace(".", ",.") + "%"
      );
  }

  // Deselect all on svg click
  function legendDeselectAll() {
    // Uninitialize selected
    SELECTED_CATEGORY = null;

    // Deselect all legend groups
    LEG.groupSelection.selectAll(".g-legend-entry").classed("selected", false);

    // Transition all data paths to default opacity
    d3.selectAll(".data-path")
      .transition("select")
      .duration(HOVER_TRANS_TIME)
      .attr("fill-opacity", OPACITY.fill.default)
      .attr("stroke-opacity", OPACITY.stroke.default);

    // Transition all data points to default opacity
    d3.selectAll(".data-point")
      .transition("select")
      .duration(HOVER_TRANS_TIME)
      .attr("fill-opacity", OPACITY.stroke.default);
  }

  // Handle selection on legend group
  function legendSelect(datum, index, el) {
    // Change selected to new item
    SELECTED_CATEGORY = datum.key;

    // Prevent event from falling through to underlying elements
    d3.event.stopPropagation();

    // Deselect all legend groups
    LEG.groupSelection.selectAll(".g-legend-entry").classed("selected", false);

    // Transition all other data paths to unfocus opacity
    d3.selectAll(".data-path")
      .transition("select")
      .duration(HOVER_TRANS_TIME)
      .filter(function(d) {
        return datum.key != d.category;
      })
      .attr("fill-opacity", OPACITY.fill.unfocus)
      .attr("stroke-opacity", OPACITY.stroke.unfocus);

    // Transition all other data points to unfocus opacity
    d3.selectAll(".data-point")
      .transition("select")
      .duration(HOVER_TRANS_TIME)
      .filter(function(d) {
        return datum.key != d.category;
      })
      .attr("fill-opacity", OPACITY.stroke.unfocus);

    // Select clicked legend group
    d3.select(el).classed("selected", true);

    // Bring selected data path to front and transition focus opacity
    d3.select("#" + datum.key + "-path")
      .moveToFront()
      .transition("select")
      .duration(HOVER_TRANS_TIME)
      .attr("fill-opacity", OPACITY.fill.focus)
      .attr("stroke-opacity", OPACITY.stroke.focus);

    // Transition selected data points to focus opacity
    d3.selectAll(".data-point")
      .filter(function(d) {
        return datum.key == d.category;
      })
      .transition("select")
      .duration(HOVER_TRANS_TIME)
      .attr("fill-opacity", OPACITY.stroke.focus);
  }

  // Tween function for x coordinates on circle
  function xTween(startRadius, endRadius, startAngle, endAngle) {
    const interpolateRadius = d3.interpolate(startRadius, endRadius);
    const interpolateAngle = d3.interpolate(startAngle, endAngle);
    return function(t) {
      const interpolatedRadius = interpolateRadius(t);
      const interpolatedAngle = interpolateAngle(t);
      return interpolatedRadius * Math.sin(interpolatedAngle);
    };
  }

  // Tween functions for y coordinates on circle
  function yTween(startRadius, endRadius, startAngle, endAngle) {
    const interpolateRadius = d3.interpolate(startRadius, endRadius);
    const interpolateAngle = d3.interpolate(startAngle, endAngle);
    return function(t) {
      const interpolatedRadius = interpolateRadius(t);
      const interpolatedAngle = interpolateAngle(t);
      return -interpolatedRadius * Math.cos(interpolatedAngle);
    };
  }
});
</script>
</body>
</html>
